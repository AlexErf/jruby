%package "org.jruby.ir.persistence.parser";

%import "org.jcodings.Encoding";

%import "org.jruby.ir.IRScope";
%import "org.jruby.ir.IRScopeType";

%import "org.jruby.ir.instructions.Instr";
%import "org.jruby.ir.operands.CompoundString";
%import "org.jruby.ir.operands.Label";
%import "org.jruby.ir.operands.Operand";
%import "org.jruby.ir.operands.Variable";
%import "org.jruby.ir.operands.KeyValuePair";

%import "org.jruby.ir.persistence.parser.dummy.MultipleParamInstr";
%import "org.jruby.ir.persistence.parser.dummy.SingleParamInstr";

%import "org.jruby.parser.IRStaticScope";
%import "org.jruby.parser.IRStaticScopeType";

%import "org.jruby.util.KCode";
%import "org.jruby.util.RegexpOptions";

%class "PersistedIRParser";

%terminals BOOLEAN, STRING_LITERAL, SYMBOL_LITERAL, ID, STRING, FIXNUM, FLOAT, NIL;
%terminals EOLN;
%terminals EQ;
%terminals DOT, COMMA, LBRACE, RBRACE, LPAREN, RPAREN, GT, LT, LBRACK, RBRACK;
%terminals ARRAY_MARKER, ARGS_PUSH_MARKER, ARGS_CAT_MARKER, BOOLEAN_MARKER, BIGNUM_MARKER, COMPOUND_STRING_MARKER, FIXNUM_MARKER, FLOAT_MARKER, IREXCEPTION_MARKER, SVALUE_MARKER, WRAPPED_IR_CLOSURE_MARKER;
%terminals SCOPE, LEXICAL_PARENT_MARKER, STATIC_SCOPE, SPECIFIC_INFO_MARKER;
%terminals SCOPE_MARKER, MODULE_MARKER;
%terminals ASTERISK, GTE, BACKTICK, COLON, DOLLAR, HASH, PERCENT;

%terminals ENSURE_BLOCK_LABEL, LABEL, COMPLEX_LABEL;

// Regexp terminals
%terminals REGEXP_MARKER, BAR, REGEXP_OPTIONS_MARKER, KCODE_MARKER;

// Range markers
%terminals EXCLUSIVE, INCLUSIVE;

// Special types of operands
%terminals UNKNOWN_SUPER_TARGET, OBJECT_CLASS, SELF, BLOCK, STANDARD_ERROR, UNDEFINED_VALUE, UNEXECUTABLE_NIL;
%terminals NULL;

%typeof STRING_LITERAL, STRING, ID, SYMBOL_LITERAL, FIXNUM, FLOAT, BOOLEAN, BLOCK, COMPLEX_LABEL, LABEL, regexp_opt_option, specific_info_element = "String";
%typeof range_type = "Boolean";
%typeof specific_info, specific_info_elements = "ArrayList<String>";
%typeof param_list = "ArrayList<Object>";
%typeof instructions = "ArrayList<Instr>";
%typeof array = "ArrayList<Operand>";
%typeof rvalue_operand, operand = "Operand";
%typeof variable = "Variable";
%typeof compound_string  = "CompoundString";
%typeof regexp_options = "RegexpOptions";
%typeof instruction = "Instr";
%typeof key_value_pair = "KeyValuePair";
%typeof label = "Label";
%typeof param = "Object";
%typeof encoding = "Encoding";

%typeof scope_info, lexical_parent, scope_descriptor = "IRScope";
%typeof scope_type = "IRScopeType";

%typeof static_scope = "IRStaticScope";
%typeof static_scope_type = "IRStaticScopeType";

%typeof single_param_instr = "SingleParamInstr";
%typeof multi_param_instr = "MultipleParamInstr";

%goal scopes;

%embed {:

    private PersistedIRParserLogic logic;

    public void init(IRParsingContext context) {
        logic = new PersistedIRParserLogic(context);
    }

:} ;

scopes
    =    scopes_info.scope EOLN
         scopes_instructions.instrs     {: return logic.getToplevelScope(); :}
    ;
    
scopes_info
    =    scope_info
    |    scopes_info scope_info
    ;
    
/* Info that is needed to recreate a scope itself, do not contain instructions */    
scope_info
    =    SCOPE LPAREN scope_type.type RPAREN COLON LT STRING.name GT COLON FIXNUM.line EOLN
         lexical_parent.parent?
         static_scope.ss
         specific_info.opt?
                                        {: return logic.createScope(type, parent, name, line, ss, opt); :}
    ;
    
scope_type
    =    ID.type                        {: return logic.createScopeType(type); :}
    ;

lexical_parent
    =    LEXICAL_PARENT_MARKER LT STRING.name GT EOLN
                                        {: return logic.findLexicalParent(name); :}
    ;

static_scope   
    =    STATIC_SCOPE LPAREN static_scope_type.type RPAREN COLON LBRACK variables.vars? RBRACK EOLN
                                        {: return logic.buildStaticScope(type, vars); :}
    ;
    
static_scope_type
    =    ID.type                        {: return logic.createStaticScopeType(type); :}
    ;
    
specific_info
    =    SPECIFIC_INFO_MARKER LPAREN specific_info_elements.info RPAREN EOLN
    ;
    
specific_info_elements
    =    specific_info_element
    |    specific_info_elements COMMA specific_info_element
    ;
    
specific_info_element
    =    FIXNUM
    |    BOOLEAN
    ;
    
variables
    =    ID
    |    variables COMMA ID
    ;
    
scopes_instructions
    =    scope_instructions EOLN
    |    scopes_instructions scope_instructions EOLN
    ;
    
scope_instructions
    =    scope_descriptor.scope EOLN
         instructions.instrs            {: return logic.addToScope(scope, instrs); :}
    ;
    
scope_descriptor
    =    SCOPE COLON LT STRING.name GT  {: return logic.enterScope(name); :}
    ;

/* Instructions */
instructions
    =    instruction.i EOLN             {: return logic.addFirstInstruction(i); :}
    |    instructions.lst instruction.i EOLN
                                        {: return logic.addFollowingInstrctions(lst, i, _symbol_lst); :}
                                        
    ;
    
instruction
    =    label_instr   
    |    simple_instr
    |    result_instr
    |    put_instr
    ;
    
label_instr
    =    label.label COLON              {: return logic.createLabelInstr(label); :}
    ;

simple_instr
    =    ID.id                          {: return logic.createInstrWithoutParams(id); :}
    // only jump so far
    |    ID.id label.target             {: return logic.createJump(target); :}
    |    single_param_instr.instr       {: return logic.createInstrWithSingleParam(instr); :}
    |    multi_param_instr.instr        {: return logic.createInstrWithMultipleParams(instr); :}
    ;
     
result_instr
    =    variable.var EQ rvalue_operand.rv
                                        {: return logic.createCopy(var, rv); :}
    |    variable.var EQ ID.id
                                        {: return logic.createReturnInstrWithNoParams(var, id); :}
    |    variable.var EQ single_param_instr.instr 
                                        {: return logic.createReturnInstrWithSingleParam(var, instr); :}
    |    variable.var EQ multi_param_instr.instr 
                                        {: return logic.createReturnInstrWithMultipleParams(var, instr); :}
    ;

put_instr
    =    single_param_instr.instr EQ operand.o
                                        {: return logic.createPutInstr(instr, o); :}
    |    multi_param_instr.instr EQ operand.o
                                        {: return logic.createPutInstr(instr, o); :}
    ;
    
/* Dummy instructions */    
single_param_instr
    =    ID.id LPAREN param.param RPAREN
                                        {: return logic.createSingleParamInstr(id, param); :}
    ;
    
multi_param_instr
    =    ID.id LPAREN param_list.list RPAREN
                                        {: return logic.createMultipleParamInstr(id, list); :}
    ;

/* Parameters of instruction */ 
param_list
    =    param.p1 COMMA param.p2        {: return logic.addFirstParam(p1, p2); :}
    |    param_list.list COMMA param.p  {: return logic.addFollowingParam(list, p, _symbol_list); :}
    ;
    
param
    =    operand
    |    FIXNUM.val                     {: return logic.createInteger(val); :}
    |    BOOLEAN.bool                   {: return logic.createBoolean(bool); :}
    |    array
    |    ID
    |    NULL
    ;

/* Operands */
operand
    =   rvalue_operand
    |   label
    ;

rvalue_operand
    =   array_operand
    |   as_string
    |   backtick_string
    |   compound_array
    |   compound_string
    |   current_scope
    |   dynamic_symbol
    |   hash
    |   immutable_literal
    |   ir_exception
    |   method_handle
    |   object_class
    |   range
    |   reference
    |   regexp
    |   scope_module
    |   splat
    |   standard_error
    |   string_literal
    |   svalue
    |   undefined_value
    |   variable
    |   wrapped_ir_closure
    ;
    
array_operand
    =   ARRAY_MARKER array.a            {: return logic.createArray(a); :}
    ;
    
array
    =   LBRACK array_elements.els? RBRACK
    ;
    
array_elements
    =   operand
    |   array_elements COMMA operand
    ;
    
as_string
    =   HASH LBRACE operand.o RBRACE    {: return logic.createAsString(o); :}
    ;
    
backtick_string
    =   BACKTICK array.a BACKTICK       {: return logic.createBacktickString(a); :}
    ;
    
compound_array
    =   ARGS_PUSH_MARKER LBRACK operand.a1 COMMA operand.a2 RBRACK
                                        {: return logic.createArgsPush(a1, a2); :}
    |   ARGS_CAT_MARKER LBRACK operand.a1 COMMA operand.a2 RBRACK
                                        {: return logic.createArgsCat(a1, a2); :}
    ;
    
compound_string
    =   COMPOUND_STRING_MARKER encoding.encoding array.pieces
                                        {: return logic.createCompoundString(encoding, pieces); :}
    ;
    
encoding
    =   ID.encoding                     {: return logic.createEncoding(encoding); :}
    ;
      
current_scope
    =   SCOPE_MARKER LT STRING.name GT
                                        {: return logic.createCurrentScope(name); :}
    ;
    
dynamic_symbol
    =    COLON compound_string.symbol_name
                                        {: return logic.createDynamicSymbol(symbol_name); :} 
    ;
    
hash
    =    LBRACE key_value_pairs.pairs? RBRACE
                                        {: return logic.createHash(pairs); :}    
    ;
    
key_value_pairs
    =    key_value_pair
    |    key_value_pairs COMMA key_value_pair
    ;
    
key_value_pair
    =    operand.key GTE operand.value    
                                        {: return logic.createKeyValuePair(key, value); :} 
    ;

immutable_literal
    =   BIGNUM_MARKER FIXNUM.b          {: return logic.createBignum(b); :}
    |   FIXNUM_MARKER FIXNUM.n          {: return logic.createFixnum(n); :}
	|	FLOAT_MARKER FLOAT.f            {: return logic.createFloat(f); :}
	|	NIL                             {: return logic.createNil(); :}
	|	UNEXECUTABLE_NIL                {: return logic.createUnexecutableNil(); :}
	|   BOOLEAN_MARKER BOOLEAN.bool     {: return logic.createBooleanLiteral(bool); :}
	;

ir_exception
    =   IREXCEPTION_MARKER ID.reason    {: return logic.createIRException(reason); :}
    ;
       
label
    =   ENSURE_BLOCK_LABEL              {: return logic.createEnsureBlockLabel(); :}
    |   LABEL.label                     {: return logic.createSimpleLabel(label); :}
    |   COMPLEX_LABEL.label             {: return logic.createComplexLabel(label); :}
    ;

method_handle
    =   LT operand.receiver DOT operand.methodName GT
                                        {: return logic.createMethodHandle(methodName, receiver); :}
    ;

object_class
    =   OBJECT_CLASS                    {: return logic.createObjectClass(); :}
    ;
 
range
    =   LPAREN operand.b range_type.isExclusive operand.e RPAREN
                                        {: return logic.createRange(b, e, isExclusive); :}
    ;
   
range_type
    =   EXCLUSIVE                       {: return new Symbol( true ); :}
    |   INCLUSIVE                       {: return new Symbol( false ); :}
    ;
    
reference
    =   backref
    |   global_variable
    |   meth_addr
    |   nth_ref
    |   symbol
    ;
    
backref
    =   DOLLAR SYMBOL_LITERAL.ch        {: return logic.createBackref(ch); :}
    ;
    
global_variable
    =   DOLLAR ID.name                  {: return logic.createGlobalVariable(name); :}
    ;
    
meth_addr
    =   SYMBOL_LITERAL.name             {: return logic.createMethAddr(name); :}
    |   UNKNOWN_SUPER_TARGET            {: return logic.createUnknownSuperTarget(); :}
    ;
    
nth_ref
    =   DOLLAR FIXNUM.num               {: return logic.createNthRef(num); :}
    ;
    
symbol
    =   COLON SYMBOL_LITERAL.s          {: return logic.createSymbol(s); :}	
    ;
    
regexp
    =   REGEXP_MARKER BAR operand.operand BAR regexp_options.options
                                        {: return logic.createRegexp(operand, options); :}	
    ;
    
scope_module
    =   MODULE_MARKER LT STRING.name GT {: return logic.createScopeModule(name); :}
    ;

regexp_options
    =   REGEXP_OPTIONS_MARKER LPAREN KCODE_MARKER ID.kcode regexp_opt_options.opt? RPAREN
                                        {: return logic.createRegexpOptions(kcode, opt); :}
    ;
    
regexp_opt_options
    =  regexp_opt_option
    |  regexp_opt_options regexp_opt_option
    ;
    
regexp_opt_option
    =  COMMA ID.opt
    ;

splat
    =   ASTERISK operand.array          {: return logic.createSplat(array); :}
    ;
    
standard_error
    =   STANDARD_ERROR                  {: return logic.createStandardError(); :}
    ;
    
string_literal
    =   STRING_LITERAL.s                {: return logic.createStringLiteral(s); :}
    ;
    
svalue
    =   SVALUE_MARKER operand.array
                                        {: return logic.createSValue(array); :}
    ;
    
undefined_value
    =   UNDEFINED_VALUE                 {: return logic.createUndefininedValue(); :}
	;
	
variable
    =   local_variable
    |   temporary_variable
    ;
    
local_variable
    =   SELF                            {: return logic.createSelf(); :}
    |   BLOCK.id LPAREN FIXNUM.scopeDepth COLON FIXNUM.location RPAREN
                                        {: return logic.createLocalVariable(id, scopeDepth, location); :}
    |   ID.id LPAREN FIXNUM.scopeDepth COLON FIXNUM.location RPAREN 
                                        {: return logic.createLocalVariable(id, scopeDepth, location); :}
    ;

temporary_variable
    =   PERCENT ID.id
                                        {: return logic.createTemporaryVariable(id); :}
    ;

wrapped_ir_closure
    =    WRAPPED_IR_CLOSURE_MARKER LT STRING.name GT
                                        {: return logic.createWrapperIRClosure(name); :}
    ;