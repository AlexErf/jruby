%package "org.jruby.ir.persistence";

%import "org.jruby.ir.Operation";

%import "org.jruby.ir.instructions.Instr";
%import "org.jruby.ir.operands.Array";
%import "org.jruby.ir.operands.CompoundString";
%import "org.jruby.ir.operands.Label";
%import "org.jruby.ir.operands.Operand";
%import "org.jruby.ir.operands.Variable";
%import "org.jruby.ir.operands.KeyValuePair";

%import "org.jruby.ir.persistence.IROperandFactory";
%import "org.jruby.ir.persistence.IRScopeBuilder";

%import "org.jruby.runtime.CallType";
%import "org.jruby.util.KCode";
%import "org.jruby.util.RegexpOptions";

%class "PersistedIRParser";

%terminals STRING_LITERAL, SYMBOL_LITERAL, ID, STRING, FIXNUM, FLOAT;
%terminals EOLN;
%terminals EQ;
%terminals DOT, SEMICOLON, COMMA, LBRACE, RBRACE, LPAREN, RPAREN, GT, LT, LBRACK, RBRACK;
%terminals ARRAY_MARKER, ARGS_PUSH_MARKER, ARGS_CAT_MARKER, BIGNUM_MARKER, COMPOUND_STRING_MARKER, FIXNUM_MARKER, FLOAT_MARKER, IREXCEPTION_MARKER, SVALUE_MARKER;
%terminals SCOPE_START_MARKER, SCOPE_MARKER, MODULE_MARKER;
%terminals ASTERISK, GTE, BACKTICK, COLON, DOLLAR, HASH, PERCENT;

// Regexp terminals
%terminals REGEXP_MARKER, BAR, REGEXP_OPTIONS_MARKER, KCODE_MARKER;

// Range markers
%terminals EXCLUSIVE, INCLUSIVE;

// Special types of operands
%terminals UNKNOWN_SUPER_TARGET, OBJECT_CLASS, SELF, STANDARD_ERROR, UNDEFINED_VALUE, UNEXECUTABLE_NIL;
%terminals NIL, TRUE, FALSE;

%typeof STRING_LITERAL, STRING, ID, SYMBOL_LITERAL, FIXNUM, FLOAT, branch_name, regexp_opt_option = "String";
%typeof array_operand = "Array";
%typeof operand = "Operand";
%typeof variable = "Variable";
%typeof compound_string  = "CompoundString";
%typeof kcode = "KCode";
%typeof call_type = "CallType";
%typeof regexp_options = "RegexpOptions";
%typeof instruction = "Instr";
%typeof key_value_pair = "KeyValuePair";
%typeof label = "Label";
%typeof param = "Object";
%typeof operation = "Operation";

%goal scope

scope
    =    SCOPE_START_MARKER LT STRING.name GT 
         instructions.instrs EOLN
                                        {: return new Symbol( IRScopeFactory.INSTANCE.createScope(name, instrs) ); :}
    ;

instructions
    =    instruction EOLN
    |    instructions instruction EOLN
    ;
    
instruction
    =    label_instr   
    |    simple_instr
    |    result_instr
    ;
    
label_instr
    =    label.label COLON              {: return new Symbol( IRInstructionFactory.INSTANCE.createLabel(label) ); :}
    ;

simple_instr
    // only tread poll so far
    =    operation.id                   {: return new Symbol( IRInstructionFactory.INSTANCE.createTreadPoll() ); :}
    // only jump so far
    |    operation label.target         {: return new Symbol( IRInstructionFactory.INSTANCE.createJump(target) ); :}
    |    operation.id LPAREN param_list.list RPAREN
                                        {: return new Symbol( IRInstructionFactory.INSTANCE.createInstrWithParams(id, list) ); :}
    ;
    
operation
    =    ID.name                        {: return new Symbol( IRInstructionFactory.INSTANCE.createOpertion(name) ); :}
    
param_list
    =    param
    |    param_list COMMA param
    ;
    
param
    =    operand
    |    FIXNUM.val                     {: return new Symbol( Integer.valueOf(val) ); :}
    |    array
    ;
     
result_instr
    =    variable.var EQ operand.op     {: return new Symbol( IRInstructionFactory.INSTANCE.createReturnInstrWithOperand(var, op) ); :}
    |    variable.var EQ operation.instr
                                        {: return new Symbol( IRInstructionFactory.INSTANCE.createReturnInstrWithNoParams(var, instr) ); :}
    |    variable EQ operation.instr LPAREN param_list.list RPAREN 
                                        {: return new Symbol( IRInstructionFactory.INSTANCE.createReturnInstrWithParams(var, instr, list) ); :}
    // only PutGlobalVarInstr so far
    |    operation.instr LPAREN operand.o1 RPAREN EQ operand.o2
                                        {: return new Symbol( IRInstructionFactory.INSTANCE.createPutGlobalVar(o1, o2) ); :}
    ;

operand
    =   array_operand
    |   array  // hack! it is here only for CallInstr
    |   as_string
    |   backtick_string
    |   compound_array
    |   compound_string
    |   current_scope
    |   dynamic_symbol
    |   hash
    |   immutable_literal
    |   ir_exception
    |   label
    |   method_handle
    |   object_class
    |   range
    |   reference
    |   regexp
    |   scope_module
    |   splat
    |   standard_error
    |   string_literal
    |   svalue
    |   undefined_value
    |   variable
    |   wrapped_ir_closure
    ;
    
array_operand
    =   ARRAY_MARKER array.a            {: return new Symbol( IROperandFactory.INSTANCE.createArray(a.value) ); :}
    ;
    
array
    =   LBRACK array_elements.els? RBRACK
    ;
    
array_elements
    =   operand
    |   array_elements COMMA operand
    ;
    
as_string
    =   DOLLAR LBRACE operand.o RBRACE  {: return new Symbol( IROperandFactory.INSTANCE.createAsString(o) ); :}
    ;
    
backtick_string
    =   BACKTICK array.a BACKTICK       {: return new Symbol( IROperandFactory.INSTANCE.createBacktickString(a) ); :}
    ;
    
compound_array
    =   ARGS_PUSH_MARKER LBRACK operand.a1 COMMA operand.a2 RBRACK
                                        {: return new Symbol( IROperandFactory.INSTANCE.createArgsPush(a1, a2) ); :}
    |   ARGS_CAT_MARKER LBRACK operand.a1 COMMA operand.a2 RBRACK
                                        {: return new Symbol( IROperandFactory.INSTANCE.createArgsCat(a1, a2) ); :}
    ;
  
current_scope
    =   SCOPE_MARKER LT STRING.name GT
                                        {: return new Symbol( IROperandFactory.INSTANCE.createCurrentScope(scope, name) ); :}
    ;
    
dynamic_symbol
    =    COLON compound_string.symbol_name
                                        {: return new Symbol( IROperandFactory.INSTANCE.createDynamicSymbol(symbol_name) ); :} 
    ;
    
hash
    =    LBRACE key_value_pairs.pairs? RBRACE
                                        {: return new Symbol( IROperandFactory.INSTANCE.createHash(pairs) ); :}    
    ;
    
key_value_pairs
    =    key_value_pair
    |    key_value_pairs COMMA key_value_pair
    
key_value_pair
    =    operand.key GTE operand.value    
                                        {: return new Symbol( IROperandFactory.INSTANCE.createKeyValuePair(key, value) ); :} 
    ;

immutable_literal
    =   BIGNUM_MARKER FIXNUM.b          {: return new Symbol( IROperandFactory.INSTANCE.createBignum(b) ); :}
    |   FIXNUM_MARKER FIXNUM.n          {: return new Symbol( IROperandFactory.INSTANCE.createFixnum(n) ); :}
	|	FLOAT_MARKER FLOAT.f            {: return new Symbol( IROperandFactory.INSTANCE.createFloat(f) ); :}
	|	NIL                             {: return new Symbol( IROperandFactory.INSTANCE.createNil() ); :}
	|	UNEXECUTABLE_NIL                {: return new Symbol( IROperandFactory.INSTANCE.createUnexecutableNil() ); :}
	|   TRUE                            {: return new Symbol( IROperandFactory.INSTANCE.createTrueLiteral() ); :}
	|   FALSE                           {: return new Symbol( IROperandFactory.INSTANCE.createFalseLiteral() ); :}
	;

ir_exception
    =   IREXCEPTION_MARKER ID.reason    {: return new Symbol( IROperandFactory.INSTANCE.createIRException(reason) ); :}
    ;
       
label
    =   ID.label                        {: return new Symbol( IROperandFactory.INSTANCE.createLabel(label) ); :}

method_handle
    =   LT operand.receiver DOT operand.methodName GT
                                        {: return new Symbol( IROperandFactory.INSTANCE.createMethodHandle(methodName, receiver) ); :}
    ;

object_class
    =   OBJECT_CLASS                    {: return new Symbol( IROperandFactory.INSTANCE.createObjectClass() ); :}
    ;
 
range
    =   exclusive_range
    |   inclusive_range
    ;
   
exclusive_range
    =   operand.b EXCLUSIVE operand.e   {: return new Symbol( IROperandFactory.INSTANCE.createExclusiveRange(b, e) ); :}
    ;
   
inclusive_range
    =   operand.b INCLUSIVE operand.e   {: return new Symbol( IROperandFactory.INSTANCE.createInclusiveRange(b, e) ); :}
    ;
    
reference
    =   backref
    |   global_variable
    |   meth_addr
    |   nth_ref
    |   symbol
    ;
    
backref
    =   DOLLAR SYMBOL_LITERAL.char      {: return new Symbol( IROperandFactory.INSTANCE.createBackref(char) ); :}
    ;
    
global_variable
    =   DOLLAR ID.name                  {: return new Symbol( IROperandFactory.INSTANCE.createGlobalVariable(name) ); :}
    ;
    
meth_addr
    =   SYMBOL_LITERAL.name             {: return new Symbol( IROperandFactory.INSTANCE.createMethAddr(name) ); :}
    ;
    
nth_ref
    =   DOLLAR FIXNUM.num               {: return new Symbol( IROperandFactory.INSTANCE.createNthRef(num) ); :}
    ;
    
symbol
    =   COLON SYMBOL_LITERAL.s          {: return new Symbol( IROperandFactory.INSTANCE.createSymbol(s) ); :}	
    ;
    
regexp
    =   REGEXP_MARKER BAR operand.operand BAR regexp_options.options
                                        {: return new Symbol( IROperandFactory.INSTANCE.createRegexp(operand, options) ); :}	
    ;

regexp_options
    =   REGEXP_OPTIONS_MARKER LPAREN KCODE_MARKER ID.kcode regexp_opt_options.opt? RPAREN
                                        {: return new Symbol( IROperandFactory.INSTANCE.createRegexpOptions(kcode, opt) ); :}
    ;
    
regexp_opt_options
    =  regexp_opt_option
    |  regexp_opt_options regexp_opt_option
    ;
    
regexp_opt_option
    =  COMMA ID.opt
    ;

scope_module
    =   MODULE_MARKER LT STRING.name GT {: return new Symbol( IROperandFactory.INSTANCE.createScopeModule(name) ); :}
    ;

splat
    =   ASTERISK operand.array          {: return new Symbol( IROperandFactory.INSTANCE.createSplat(array) ); :}
    ;
    
standard_error
    =   STANDARD_ERROR                  {: return new Symbol( IROperandFactory.INSTANCE.createStandardError() ); :}
    ;
    
string_literal
    =   STRING_LITERAL.s                {: return new Symbol( IROperandFactory.INSTANCE.createStringLiteral(s) ); :}
    ;
    
svalue
    =   SVALUE_MARKER operand.array
                                        {: return new Symbol( IROperandFactory.INSTANCE.createSValue(array) ); :}
    ;
    
undefined_value
    =   UNDEFINED_VALUE                 {: return new Symbol( IROperandFactory.INSTANCE.createUndefininedValue() ); :}
	;
	
variable
    =   local_variable
    |   temporary_variable
    ;
    
local_variable
    =   SELF                            {: return new Symbol( IROperandFactory.INSTANCE.createSelf() ); :}
    |   LT ID.id LPAREN FIXNUM.scopeDepth COLON FIXNUM.offset  RPAREN GT // not implemented!    
                                        {: return new Symbol( IROperandFactory.INSTANCE.createClosureLocalVariable(scope, id, scopeDepth, offset) ); :}
    |   ID.id LPAREN FIXNUM.scopeDepth COLON FIXNUM.offset  RPAREN 
                                        {: return new Symbol( IROperandFactory.INSTANCE.createLocalVariable(id, scopeDepth, offset) ); :}
    ;

temporary_variable
    =   PERCENT ID.id                   {: return IROperandFactory.INSTANCE.createTemproraryVariable(id); :}
//    |    temporary_closure_variable
    ;

//temporary_closure_variable
//    :   PERCENT ID.id
//    ;